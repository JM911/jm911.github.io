---
layout: single
title:  "백준 22870 - 산책(large)"
categories: ps
tag: [algorithm, boj, cpp]
toc: true
---

알고리즘 풀이는 한 번도 올린 적이 없지만 이 문제는 상당히 고생을 하기도 했고, C++ 풀이를 찾기가 힘들어서 기록차 생각 과정을 남겨놓으려 한다.  
(물론 구현보다는 아이디어가 핵심이라 언어 종류가 크게 중요하지는 않다)  

문제 링크: [https://www.acmicpc.net/problem/22870](https://www.acmicpc.net/problem/22870)  

![image](https://jm911.github.io/assets/images/240318/1.png){: width="100%" height="100%" .align-center}  

## 문제 분석
일단 문제가 특정 점에서 부터의 최단거리와 관련이 있고, 정점 최대 개수 N이 20만이나 되는 큰 숫자인 것으로 보아 다익스트라를 활용해야 하는 것이 어느 정도 짐작된다.  
다만 최소 경로가 2개 이상일 때 어떤 경로를 택하는지가 핵심이고, 그 경로를 고르는 기준이 '사전순'이라는 것이 이 문제를 고민하게 만든다.  

풀이에 앞서 자명하게 알 수 있는 부분은 처음 S->E 로 가는 경로만 잘 구하면 E->S 로 돌아오는 경로는 (첫 경로의 정점을 모두 지운 후) 최단 경로로 아무거나 고르면 되기 때문에 단순 다익스트라를 쓰면 된다.  
즉, S->E 로 갈 때의 경로를 문제 조건에 맞게 고르려면 어떻게 해야하는지가 이 문제에서 구현할 핵심 부분이라는 것.  
아래 세 가지 시도는 위 사항을 풀기 위해 내가 생각을 어떻게 바꿔나갔는지에 대한 기록이다.  


## 첫 번째 시도 - 브루트 포스

처음 생각난 아이디어는 **S->E 에 대한 다익스트라를 수행하며 모든 최소 경로를 저장하여 최후에 사전순 비교를 통해 적당한 경로를 찾는 것**이었다.  
일반적으로 다익스트라를 사용할 때 경로 저장이 필요하다면 각 정점 별로 "이전 정점"을 저장하며 다익스트라를 수행하고, 끝난 후 도착지부터 거꾸로 거슬러 가며 경로를 구한다.  
보통은 같은 수치의 거리에 대한 경로는 무시하기 때문에 딱 하나씩만 저장하는데, 여기서는 같은 거리의 경로들 중에서도 우선순위가 있기 때문에 우선 모든 경로를 저장해야 한다.  
즉, "이전 정점"을 저장할 때 한 개만 저장하는 게 아니라 "이전 정점이 될 수 있는 모든 정점들"로 저장해야 한다는 것이다.  
  
이후 끝점 E부터 역으로 DFS 탐색하며 모든 경로를 구하는데, 이때 완성된 경로가 하나 나올 때마다 지금까지의 최소 경로와 사전 순 비교하여 답을 교체하면서 탐색을 진행한다.  
여기서 주의할 점은 끝점부터의 탐색이기 때문에 완성된 경로가 아닌 이상 어떤 정점을 고르는 지가 의미 없다는 것이다.  
예를 들어 두 가지 경로 "A-B-E-F" 와 "A-D-C-F" 가 있다고 하면, 마지막 F 점 기준으로 이전 정점 중 가장 앞에 오는 것은 C 점이지만, 이는 전체 경로의 사전 순서와는 관련이 없다.  
결국 이 방법으로는 모든 경로를 탐색하는 것 밖에 답이 없다는 것이다.  
  
경로를 저장하는 것 까지는 단순한데, DFS로 모든 경로릍 탐색하는 방식을 어떻게 하는지에 따라 시간 초과와 통과로 나뉘었다. 
  
### (1) 무작정 탐색하기 - 시간 초과
제출 링크: [https://www.acmicpc.net/source/74439545](https://www.acmicpc.net/source/74439545)  
  
여기서 `prevIdx[v]` 는 int형 배열이며, 'v에 최단거리로 도달할 경우 가능한 이전 정점들의 집합' 으로 놓고 위에서 설명한 것처럼 사용했다.  
어쨌든 본 답안은 당연하게도 시간 초과로 통과하지 못했다.  
  
간단하게만 생각해봐도 만약 100개 짜리 정점 두 묶음이 서로에게 모두 연결되어 있다고 가정하면 100 * 100 = 10000 개의 간선으로 충분하다.  
  
![image](https://jm911.github.io/assets/images/240318/2.png){: width="100%" height="100%" .align-center}  
  
정점은 최대 20만개라서 따질 것도 없고, 간선은 최대 50만개이니 이런 간선 묶음이 출발 ~ 도착 지점 사이에 대략 49개가 있고 모두 같은 거리라서 최단 거리라고 가정하면... 모든 최단 경로 가지수는 당연히 미친듯이 많아진다.  
  
![image](https://jm911.github.io/assets/images/240318/3.png){: width="100%" height="100%" .align-center}  
  
  
### (2) 중복 탐색 제어 - 성공
따라서 어느 정도 중복되는 경로를 탐색하지 않는 것이 중요한데, 이 부분이 글로 설명하기는 살짝 어렵다.  
최대한 풀어서 써보자면 아래와 같다.  
  
1. nextIdx 배열을 만들어 특정 정점을 지나칠 때 고를 다음 정점을 저장한다. 앞에서처럼 고를 수 있는 정점이 여러개라면 당연히 사전순으로 맨 앞에 오는 것만 저장한다.
    - 여기서 하나만 저장해도 되는 이유는 '이전' 정점이 아닌 '다음' 정점이기 때문이다. 
    - '이전' 정점들은 앞 쪽 경로가 어떻게 바뀔지에 따라 최종적인 경로 순서도 바뀌기 때문에 미리 걸러낼 수 없는 것인데, '다음' 정점이라면 앞 쪽 경로가 고정된 상태라면 그 다음 정점이 사전순 정렬의 기준이 되므로 가능성이 없는 것들을 미리 쳐내고 최우선 정점만 저장해도 되는 것이다.
2. DFS에서 한 번 지나친 정점을 다시 지나칠 때는 1번 작업만 한 뒤 스킵한다.
    - 만약 정점 V를 한 번 방문했다고 하자.
    - 당연하게도 첫 방문 시 DFS에 의해 V 부터 출발점까지의 경로를 모두 탐색했을 것이 뻔하고, 어차피 1번 작업에 의해 nextIdx를 저장하여 확정지을 것이므로 굳이 두번 세번 이 작업을 반복할 필요는 없다.
    - 첫 시도에서는 nextIdx를 저장하지 않았으므로 모든 경우에 대해 완성된 하나의 경로를 만들어 비교했어야 하므로 중복 작업을 수행한 것인데, 여기서는 그럴 필요가 없다.
3. 모든 작업이 끝나면 nextIdx 에 저장된 정보를 바탕으로 최종 경로를 구한다. 
4. 이후 과정은 다른 풀이와 동일하게 앞선 경로를 피해가며 E->S 최단거리를 구하면 된다.
  
제출 링크: [https://www.acmicpc.net/source/74451922](https://www.acmicpc.net/source/74451922)
  
다행히 이 방법으로는 문제를 통과하였다. 다만 시간이 1104 ms 로 다른 사람들이 제출한 300~400 ms 정도 수준에 못미치는 답이었다.  
상수배 차이 정도라서 오버헤드나 몇 가지 쓸 데 없는 연산이 있나 싶었는데 딱히 그런 것도 알기 힘들어서 한 번 다른 답이 있는지 좀 더 찾아보기로 했다.  
  
  
## 두 번째 시도 - 다른 아이디어
여기서는 첫 번째 시도에서 생긴 딜레마를 역으로 이용했다.  
처음에는 S->E 를 탐색하며 prevIdx 를 저장했기 때문에 뒤쪽 경로부터 알게 되는 문제로 인해 사전순 정렬에 애를 먹었다.  
그렇다면 반대로 E->S 를 먼저 탐색하고 이 경로의 prevIdx 를 저장한다면... S->E 로 가는 nextIdx 를 구하는 형태가 되어버리므로 마지막 사전순 최우선 경로를 고르는 것이 크게 편해진다는 것이다.  
만약 방향 그래프라면 경로 방향을 반대로 만든 뒤 탐색해야 할 것이고, 여기는 무방향 그래프라서 이런 처리조차도 필요 없다.  
이 방법을 사용한 코드는 다음과 같다.

```cpp
#define FASTIO cin.tie(nullptr); ios_base::sync_with_stdio(false)
#include "bits/stdc++.h"
using namespace std;

using pii = pair<int, int>;
const int INF = 2e9;

int N, M, S, E;
vector<unordered_map<int, int>> adj;
vector<int> dist;
vector<int> prevIdx;

vector<int> minPath;
unordered_set<int> visited;
int ans;

int main()
{
	FASTIO;

	cin >> N >> M;
	adj.resize(N+1);

	while(M--)
	{
		int A, B, C;
		cin >> A >> B >> C;

		adj[A].insert({B, C});
		adj[B].insert({A, C});
	}

	cin >> S >> E;

	priority_queue<pii, vector<pii>, greater<pii>> pq;
	
	dist.resize(N+1, INF);
	prevIdx.resize(N+1, -1);

    // 첫 경로 구할 때 E에서 출발 -> S 도착으로 구하기
	dist[E] = 0;
	pq.push({0, E});

	while(!pq.empty())
	{
		auto [curD, curV] = pq.top();
		pq.pop();

		for(auto e : adj[curV])
		{
			int nextD = curD + e.second;
			int nextV = e.first;

			if(nextD > dist[nextV]) continue;
			if(nextD == dist[nextV])
				prevIdx[nextV] = min(prevIdx[nextV], curV);
			else
			{
				dist[nextV] = nextD;
				prevIdx[nextV] = curV;
				pq.push({nextD, nextV});
			}
		}
	}

	ans += dist[S];

    // 첫 경로에서 들어간 정점을 visited 에 저장 (두 번째 경로 구할 때 스킵용)
	int curIdx = prevIdx[S];
	while(curIdx != E)
	{
		visited.insert(curIdx);
		curIdx = prevIdx[curIdx];
	}

	dist.clear();
	dist.resize(N+1, INF);

    // 두 번째 경로 구하는 건 평범한 다익스트라
	dist[E] = 0;
	pq.push({0, E});

	while(!pq.empty())
	{
		auto [curD, curV] = pq.top();
		pq.pop();

		for(auto e : adj[curV])
		{
			int nextD = curD + e.second;
			int nextV = e.first;

            // 첫 경로에 포함된 정점이라면 스킵
			if(visited.find(nextV)!=visited.end() || nextD>=dist[nextV]) continue;

			dist[nextV] = nextD;
			pq.push({nextD, nextV});
		}
	}

	ans += dist[S];

	cout << ans;
}
```
제출 링크: [https://www.acmicpc.net/source/74457307](https://www.acmicpc.net/source/74457307)  
  
개인적으로 다익스트라를 함수로 만들고 쓰지 않아서 코드가 좀 보기 안좋다😋  
어쨌든 이 정도 풀이만 해도 훌륭하다고 생각하지만, 여전히 동작 시간이 1초가 넘고, 목표치에 도달한 것은 아니므로 다른 사람들은 대체 어떻게 풀었을 지 궁금해졌다.  
결국 풀이도 찾아보고 다른 사람의 코드를 보니 꽤 재밌고 나중에도 유용할 것 같은 아이디어를 쓰고 있어서 재밌어서 구현 후 가져와봤다.  
  
  
## 세 번째 시도 - 찾아본 풀이
본 풀이에서도 E->S 부터 거꾸로 구하는 아이디어가 핵심적으로 사용됐다. 다만 이후에 사전순 최우선 경로를 구할 때 '미리 정렬'을 해놓고 탐색하여 쓸 데 없는 계산을 쳐낸 것으로 보인다.  
순서는 다음과 같다.  

1. 경로 입력을 모두 받은 후 각 경로들을 모두 "다음 정점의 사전순"으로 미리 정렬한다.
    - 보통 `vector<pair<int, int>> adj[N]` 을 선언하여 `adj[V]` 에는 V와 연결된 정점과 거리를 저장해놓는데, 각각의 `adj[V]`를 정점 순서대로 정렬해놓는 것이다.
2. 앞선 풀이와 마찬가지로 E->S 로 가는 최단 거리를 구한다. 여기서 prevIdx 는 따로 저장하지 않고 각 정점까지의 최단 거리를 모두 저장해놓는다.
    - 사실 각 정점까지의 최단거리를 저장하는 건 다익스트라를 사용하면 무조건 해야하는 작업이다. 
    - 여기서는 `int dist[N]` 배열로 선언하여 저장한다. 따라서 `dist[S]`가 자동적으로 E->S 로 가는 최단거리가 된다.
3. 모두 끝나면 S->E 로 가는 경로를 구한다.
    - `int curIdx = S` 로 현재 정점을 뜻하는 변수를 놓고 이것이 E 에 도달할 때까지 경로 점들을 체크하는 것이다. (두 번째 경로 구할 때 스킵하는 용도)
    - 이 때 탐색 순서가 curIdx 와 연결된 정점 중 **사전순으로 앞에 있는 것**부터 이뤄지게 되는데, 이는 1번에서 미리 정렬해놓은 효과이다.
    - 탐색 시 이 정점이 최단 거리 경로에 포함되는지 확인하는 것은 누적거리, 다음 정점까지의 거리, 다음 정점부터 E까지 남은 거리를 통해 알 수 있다.
        `(누적 거리) + (다음 정점까지의 거리) + (E까지 남은 거리) == (E->S 최단 거리)`
    - 누적 거리는 별도 변수로 놓고 정점이 저장할 때마다 합친다. (초기값 0)
    - 다음 정점까지의 거리는 adj 를 탐색할 때 같이 딸려 나오므로 자연스럽게 알 수 있다.
    - 다음 정점부터 E 까지 남은 거리는 아까 dist에 저장해놨으므로 알 수 있다.
4. 이후 과정은 다른 풀이와 동일하게 앞선 경로를 피해가며 E->S 최단거리를 구하면 된다.

제출 링크: [https://www.acmicpc.net/source/74460128](https://www.acmicpc.net/source/74460128)

실행 시간은 388 ms 로 2배 이상 빨라졌다.  

## 해결할 부분
생각할 거리가 많은 문제였지만 결국 왜 마지막 풀이가 더 빠른지 명확하게 알지는 못했다.  
어렴풋이 미리 정렬을 통한 오버헤드 감소가 있을 거라고 짐작은 되지만 계산을 통해서 납득하질 못했다.  
다만 여기서 다음 두 가지는 확실하게 배우고 넘어간 것 같다.

1. 한 쪽 방향의 풀이가 원하는 순서와 반대로 나와서 힘들 때는 완전히 반대로 풀어도 되는지 생각해보자.
2. 탐색의 숫자가 많아 시간이 늘어질 때는 미리 정렬을 하는 테크닉을 떠올려보자.



